<html><head><script type="text/javascript">
map_elt = null;
kp_elt = null;

map_text = "    ";
buffer_width = 2; buffer_height = 2;
vision_distance = 10;
event_distance = 20;
loc_x = 0;
loc_y = 0;

function Terrain(char, desc, move) {
    this.char = char; this.desc = desc; this.move = move;
}

terrain_options = {
    "bare_dirt" : new Terrain("_", "bare dirt", 1)
    ,"grass" : new Terrain("v", "grass", 1)
    ,"tree" : new Terrain("TY", "tree", 10)
};

terrain_mapping = {
    "_" : terrain_options["bare_dirt"]
    ,"v" : terrain_options["grass"]
    ,"Y" : terrain_options["tree"]
    ,"T" : terrain_options["tree"]
}

terrain_distribution = "_____vvvvYT";

function paint_map() {
    s = "";
    for (y = -vision_distance; y <= vision_distance; y++) {
	for (x = -vision_distance; x <= vision_distance; x++) {
	    // todo: add vision range computation (sqrt(sqr(x) + sqr(y)))
	    if (x || y) s += map_text[(loc_y + y) * buffer_width + loc_x + x];
	    else s += '@';
	}
	s += "\n";
    }
    map_elt.innerHTML = "<pre>" + s + "</pre>";
}

function pick_char(x, y) {
    c = terrain_distribution[Math.floor(Math.random() * terrain_distribution.length)];
    i = Math.floor(Math.random() * 15);
    if (i > 11) return c;
    switch (i) {
	case 0:
	    i = (y - 1) * buffer_width + x - 1;
	    break;
	case 1:
	case 2:
	    i = (y - 1) * buffer_width + x;
	    break;
	case 3:
	    i = (y - 1) * buffer_width + x + 1;
	    break;
	case 4:
	case 5:
	    i = y * buffer_width + x - 1;
	    break;
	case 6:
	case 7:
	    i = y * buffer_width + x + 1;
	    break;
	case 8:
	    i = (y + 1) * buffer_width + x - 1;
	    break;
	case 9:
	case 10:
	    i = (y + 1) * buffer_width + x;
	    break;
	case 11:
	    i = (y + 1) * buffer_width + x + 1;
	    break;
    }
    if (map_text[i] == ' ') return c;
    return map_text[i];
}

function place_terrain(x, y) {
    c = pick_char(x, y);
    map_text = map_text.substr(0, y * buffer_width + x) + c + map_text.substr(y * buffer_width + x + 1);
}

function pad_string(char, len) {
    for (s = "", i = len; i; s += char, i--) { ; }
    return s;
}

function check_map() {
    while(loc_x < event_distance) {
	// add to the left
	for (y = buffer_height - 1; y >= 0; y--) {
	    map_text = map_text.substr(0, y * buffer_width) + " " + map_text.substr(y * buffer_width);
	}
	buffer_width++; loc_x++;
	for (y = 0; y < buffer_height - 2; y++) { place_terrain(1, y + 1); }
    }
    while(loc_x + event_distance > buffer_width - 1) {
	// add to the right
	for (y = buffer_height; y; y--) {
	    map_text = map_text.substr(0, y * buffer_width + 1) + " " + map_text.substr(y * buffer_width + 1);
	}
	buffer_width++;
	for (y = 0; y < buffer_height - 2; y++) { place_terrain(buffer_width - 2, y + 1); }
    }
    while(loc_y < event_distance) {
	// add to the top
	map_text = pad_string(" ", buffer_width) + map_text;
	buffer_height++; loc_y++;
	for (x = 0; x < buffer_width - 2; x++) { place_terrain(x + 1, 1); }
    }
    while(loc_y + event_distance > buffer_height - 2) {
	// add to the bottom
	map_text = map_text + pad_string(" ", buffer_width);
	buffer_height++;
	for (x = 0; x < buffer_width - 1; x++) { place_terrain(x + 1, buffer_height - 2); }
    }
}

function kp(e) {
    kp_elt.innerHTML = " keypress: " + e.charCode + " + " + e.keyCode;
    switch(e.charCode) {
	case 0:
	    switch(e.keyCode) {
		case 37: loc_x -= 1; break;
		case 38: loc_y -= 1; break;
		case 39: loc_x += 1; break;
		case 40: loc_y += 1; break;
	    }
	    break;
    }
    check_map();
    paint_map();
}

function go() {
    map_elt = document.getElementById("map");
    kp_elt = document.getElementById("kp");
    check_map();
    paint_map();
    document.onkeypress = kp;
}
</script></head><body onload="go()">
<div id="map">
</div>
<div id="kp">
</div>
</body></html>
